# Домашнее задание 2 по курсу "Python и основы Linux".

Дорогие друзья, ваше второе домашнее задание. По сдаче все также, закомиттье его в репозиторий (в тот же, где вы сдавали первую задачу) и направьте письмо с темой "ФТиАД25: домашнее задание 2". 

Дедлайн - **12 декабря 2025 г. в 23:59**. Дедлайн жесткий, в случае его пропуска за дз автоматически выставляется оценка 4.

Обязательно приложите к ДЗ файл `README.md` с пояснениями, как вы делали задание, что получилось в итоге, какие проблемы были и что вы поняли в процессе его выполнения. 

## 1 Сравнение подходов: Процессы vs Потоки (GIL, CPU-bound)

Напишите скрипт (не FastAPI), который вычисляет сумму квадратов чисел от 1 до 1000000. 

1. Реализуйте синхронную версию;
2. Реализуйте версию, где распараллеливание будет по потокам;
3. Реализуйте версию, где распараллеливание будет по процессам

Замерьте время выполнения всех трех версий. Прокомментируйте ваши наблюдения. 



## 2. Первое асинхронное приложение

Создайте простое FastAPI приложение с одним эндпоинтом `/delay/{seconds}`. При GET-запросе на этот эндпоинт сервер должен "заснуть" на указанное количество секунд, а затем вернуть сообщение `"Done waiting for {seconds} seconds"`.

Напишите скрипт, который направит в ваше приложение 100 запросов, каждый из которых заставит сервис заснуть на рандомное кол-во секунд (от 1 до 60).

Напишите текстовый комментарий со своими наблюдениями. Через сколько времени вам вернется ответ на последний запрос? 

## 3. Интеграция с внешним API (IO-bound)

Напишите простое приложение на fastapi, которое будет реализовывать два эндпоинта:
1. `/best` - Возвращает подборку лучших анекдотов за день. День передается в формате `%d-%B-%Y` (Например `01-January-2025`)
2. `/random` - Возвращает подборку случаных анекдотов. 

В задании предполагается использовать сайт [Анекдот.ру](https://www.anekdot.ru/). В консоли разработчика вы можете найти по какому адресу нужно обратиться, чтобы забрать нужные данные. 
Выходные данный каждой из ручек должны содержать список словарей со следующими ключами: 
* text (Текст анекдота)
* autor_profile (Ссылка на профиль автора)
* rating (Оценка анекдота)

Обратите внимание, что входная дата содержит месяц, используйте локализацию en_US. Об этом можно почитать в документации по модулю [datetime](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes).

В задании обязательно использовать pydantic.

## 4. Асинхронный контекстный менеджер

Создайте асинхронный контекстный менеджер `AsyncTimer`, который замеряет время выполнения блока кода. Он должен иметь методы `__aenter__` и `__aexit__`. Для демонстрации работы также создайте FastAPI приложение, где ручка будет работать через ваш асинхронный менеджер, засыпать на случайное количество времени.  


## 5. Управление бибилотекой
Реализуйте систему для управления книгами в библиотеке с помощью классов. 

Описание вашей системы:
* Базовый класс Book:
  1. Атрибуты: `title` (название), `author` (автор), `year` (год издания), `is_available` (доступна ли для выдачи)
  2. Методы:
    * `get_info()` - возвращает строку с информацией о книге
    * `borrow()` - выдать книгу (меняет статус доступности)
    * `return_book()` - вернуть книгу
* Класс-наследник TextBook:
  1. Добавляет атрибут `subject` (предмет)
  2. Переопределяет метод get_info(), чтобы он включал информацию о предмете
* Класс Library:
  1. Атрибут: список книг
  2. Методы:
    * `add_book(book)` - добавить книгу в библиотеку
    * `find_books_by_author(author)` - найти все книги указанного автора
    * `get_available_books()` - получить список доступных книг
    * `borrow_book(title)` - выдать книгу по названию

Пример использования:
```{python}
# Создание книг
book1 = Book("Преступление и наказание", "Ф.М. Достоевский", 1866)
book2 = TextBook("Алгебра", "И.И. Иванов", 2020, "Математика")

# Работа с библиотекой
library = Library()
library.add_book(book1)
library.add_book(book2)

# Демонстрация работы
print(library.get_available_books())
library.borrow_book("Алгебра")
print(book2.is_available)  # Должно быть False
```

## 6. Асинхронный сканер веб-сайтов с сграничением запросов

Требуется написать программу, которая асинхронно проверяет доступность списка веб-сайтов, но с ограничением количества одновременных запросов, чтобы не перегружать сеть или целевые сервера.

* Чтение URLs: Программа должна читать список URL-адресов из текстового файла (urls.txt).
* Ограничение Потока: Одновременно должно выполняться не более N запросов (N задается пользователем).
* Проверка Доступности: Для каждого URL выполнить HTTP GET запрос и определить, "доступен" ли сайт (например, статус код 200-299) или "недоступен" (все остальные статус-коды, таймауты, ошибки соединения).
* Сбор Результатов: Записать результаты в файл results.txt в формате URL - STATUS.
* Прогресс-бар (Опционально, но желательно): Выводить в консоль прогресс выполнения (например, с помощью библиотеки tqdm).

Ключевые концепции asyncio, которые будут затронуты:
1. Создание и управление задачами: `asyncio.create_task()`
2. Ожидание завершения задач: `asyncio.gather()`
3. Ограничение одновременного выполнения: `asyncio.Semaphore`
4. Асинхронные HTTP-запросы: Использование библиотеки `aiohttp`.
5. Работа с файлами: Использование `aiofiles` (опционально) или синхронная запись, так как это не узкое место.
6. Обработка ошибок: `try...except` внутри асинхронных функций.


## Вопросы

По мере выполенения у вас будет много вопросов, прошу не стесняться и писать в личку (но предварительно погуглив и почитать документацию). 
